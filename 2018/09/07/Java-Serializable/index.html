<!DOCTYPE html>
<html class="has-navbar-fixed-top">
<head>
    <meta charset="utf-8">
<title>Java_Serializable - Something</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">











<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">

<link rel="stylesheet" href="/css/style.css">

<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>



</head>
<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                <img src="/images/logo.png" alt="" height="28">
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-end">
            
            
            
        </div>
    </div>
</nav>

    <section class="section">
    <div class="container">
    <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            Java_Serializable
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-09-07T16:00:00.000Z" itemprop="datePublished">Sep 7 2018</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Java/">Java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            7 minutes read (About 1037 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>由于对象在程序结束的时候会被销毁，因此如果希望对象能够在程序不运行的时候仍然能保存信息，那么就需要用到对象的序列化操作，简单来说就是将对象转换成字节序列，等需要的时候再反序列化即可读取其中的信息。又或者在Android开发中通过intent传递对象的时候，需要将对象序列化然后才能传递。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment hljs-comment">//写入文件</span></span><br><span class="line">ObjectOutputStream objectOutputStream = <span class="keyword hljs-keyword">new</span> ObjectOutputStream(<span class="keyword hljs-keyword">new</span> FileOutputStream(<span class="string hljs-string">"test.obj"</span>));</span><br><span class="line">objectOutputStream.writeObject(<span class="keyword hljs-keyword">new</span> Data(<span class="number hljs-number">1</span>));</span><br><span class="line">objectOutputStream.close();</span><br><span class="line"><span class="comment hljs-comment">//读取文件</span></span><br><span class="line">ObjectInputStream objectInputStream = <span class="keyword hljs-keyword">new</span> ObjectInputStream(<span class="keyword hljs-keyword">new</span> FileInputStream(<span class="string hljs-string">"test.obj"</span>));</span><br><span class="line">Data data = (Data) objectInputStream.readObject();</span><br><span class="line">System.out.println(data);</span><br></pre></td></tr></table></figure>
<h2 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h2><p>如果某个类的属性不希望被序列化则可以加上transient关键字。<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword hljs-keyword">transient</span>  <span class="keyword hljs-keyword">private</span> String str;</span><br></pre></td></tr></table></figure></p>
<p>当在反序列化读取的时候就会为null或者是类型的默认值。</p>
<h2 id="序列化中的static"><a href="#序列化中的static" class="headerlink" title="序列化中的static"></a>序列化中的static</h2><p>如果在序列化之后修改了static类型的变量，那么打印出来会如何呢<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class hljs-class"><span class="keyword hljs-keyword">class</span> <span class="title hljs-title">Data</span> <span class="keyword hljs-keyword">implements</span> <span class="title hljs-title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword hljs-keyword">private</span> <span class="keyword hljs-keyword">int</span> n;</span><br><span class="line">    <span class="keyword hljs-keyword">transient</span> <span class="keyword hljs-keyword">public</span> <span class="keyword hljs-keyword">static</span> <span class="keyword hljs-keyword">int</span> i = <span class="number hljs-number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function hljs-function"><span class="keyword hljs-keyword">public</span> <span class="title hljs-title">Data</span><span class="params hljs-params">(<span class="keyword hljs-keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword hljs-keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta hljs-meta">@Override</span></span><br><span class="line">    <span class="function hljs-function"><span class="keyword hljs-keyword">public</span> String <span class="title hljs-title">toString</span><span class="params hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword hljs-keyword">return</span> <span class="string hljs-string">"Data&#123;"</span> +</span><br><span class="line">                <span class="string hljs-string">"n="</span> + n +</span><br><span class="line">                <span class="string hljs-string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function hljs-function"><span class="keyword hljs-keyword">public</span> <span class="keyword hljs-keyword">static</span> <span class="keyword hljs-keyword">void</span> <span class="title hljs-title">main</span><span class="params hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword hljs-keyword">try</span> &#123;</span><br><span class="line">        ObjectOutputStream objectOutputStream = <span class="keyword hljs-keyword">new</span> ObjectOutputStream(<span class="keyword hljs-keyword">new</span> FileOutputStream(<span class="string hljs-string">"test.obj"</span>));</span><br><span class="line">        objectOutputStream.writeObject(<span class="keyword hljs-keyword">new</span> Data(<span class="number hljs-number">1</span>));</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line"></span><br><span class="line">        Data.i = <span class="number hljs-number">10</span>;</span><br><span class="line">        ObjectInputStream objectInputStream = <span class="keyword hljs-keyword">new</span> ObjectInputStream(<span class="keyword hljs-keyword">new</span> FileInputStream(<span class="string hljs-string">"test.obj"</span>));</span><br><span class="line">        Data data = (Data) objectInputStream.readObject();</span><br><span class="line">        System.out.println(data);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果是10，原因是static是针对类的属性，而不是针对对象的属性。因为静态变量可以直接使用，所以序列化并不保存静态变量。</p>
<h2 id="Externalizable"><a href="#Externalizable" class="headerlink" title="Externalizable"></a>Externalizable</h2><p>Externalizable是一个继承Serializable的接口，并增加了两个方法<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword hljs-keyword">public</span> <span class="class hljs-class"><span class="keyword hljs-keyword">interface</span> <span class="title hljs-title">Externalizable</span> <span class="keyword hljs-keyword">extends</span> <span class="title hljs-title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function hljs-function"><span class="keyword hljs-keyword">void</span> <span class="title hljs-title">writeExternal</span><span class="params hljs-params">(ObjectOutput var1)</span> <span class="keyword hljs-keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="function hljs-function"><span class="keyword hljs-keyword">void</span> <span class="title hljs-title">readExternal</span><span class="params hljs-params">(ObjectInput var1)</span> <span class="keyword hljs-keyword">throws</span> IOException, ClassNotFoundException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这两个放在分别会在write和read的时候调用，我们可以实现这个接口，如果有其他操作可以放在这两个方法中，并且他会readExternal之前调用该类的无参构造方法。<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class hljs-class"><span class="keyword hljs-keyword">class</span> <span class="title hljs-title">Data</span> <span class="keyword hljs-keyword">implements</span> <span class="title hljs-title">Externalizable</span> </span>&#123;</span><br><span class="line">    <span class="keyword hljs-keyword">private</span> <span class="keyword hljs-keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function hljs-function"><span class="keyword hljs-keyword">public</span> <span class="title hljs-title">Data</span><span class="params hljs-params">(<span class="keyword hljs-keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword hljs-keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function hljs-function"><span class="keyword hljs-keyword">public</span> <span class="title hljs-title">Data</span><span class="params hljs-params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string hljs-string">"no pm constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta hljs-meta">@Override</span></span><br><span class="line">    <span class="function hljs-function"><span class="keyword hljs-keyword">public</span> String <span class="title hljs-title">toString</span><span class="params hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword hljs-keyword">return</span> <span class="string hljs-string">"Data&#123;"</span> +</span><br><span class="line">                <span class="string hljs-string">"n="</span> + n +</span><br><span class="line">                <span class="string hljs-string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta hljs-meta">@Override</span></span><br><span class="line">    <span class="function hljs-function"><span class="keyword hljs-keyword">public</span> <span class="keyword hljs-keyword">void</span> <span class="title hljs-title">writeExternal</span><span class="params hljs-params">(ObjectOutput objectOutput)</span> <span class="keyword hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string hljs-string">"writeExternal()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta hljs-meta">@Override</span></span><br><span class="line">    <span class="function hljs-function"><span class="keyword hljs-keyword">public</span> <span class="keyword hljs-keyword">void</span> <span class="title hljs-title">readExternal</span><span class="params hljs-params">(ObjectInput objectInput)</span> <span class="keyword hljs-keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string hljs-string">"readExternal()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function hljs-function"><span class="keyword hljs-keyword">public</span> <span class="keyword hljs-keyword">static</span> <span class="keyword hljs-keyword">void</span> <span class="title hljs-title">main</span><span class="params hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword hljs-keyword">try</span> &#123;</span><br><span class="line">        ObjectOutputStream objectOutputStream = <span class="keyword hljs-keyword">new</span> ObjectOutputStream(<span class="keyword hljs-keyword">new</span> FileOutputStream(<span class="string hljs-string">"test.obj"</span>));</span><br><span class="line">        objectOutputStream.writeObject(<span class="keyword hljs-keyword">new</span> Data(<span class="number hljs-number">1</span>));</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line"></span><br><span class="line">        ObjectInputStream objectInputStream = <span class="keyword hljs-keyword">new</span> ObjectInputStream(<span class="keyword hljs-keyword">new</span> FileInputStream(<span class="string hljs-string">"test.obj"</span>));</span><br><span class="line">        Data data = (Data) objectInputStream.readObject();</span><br><span class="line">        System.out.println(data);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Result:</span><br><span class="line">writeExternal()</span><br><span class="line">no pm constructor</span><br><span class="line">readExternal()</span><br><span class="line">Data&#123;n=0&#125;</span><br></pre></td></tr></table></figure>
<p>奇怪的是打印出的n居然是零，但是我们写进去的是一个n=1的对象。原因是Externalizable调用了无参的构造方法重新赋值了一遍。</p>
<p>这也是Serializable和Externalizable最大的区别：Serializable是完全根据二级制文件来构造对象，但是Externalizable是根据构造方法和readExternal方法来构造的。</p>
<p>因此正确的做法需要在writeExternal和readExternal的时候写入和赋值。这样的好处是更容易控制变量的存亡。</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta hljs-meta">@Override</span></span><br><span class="line"><span class="function hljs-function"><span class="keyword hljs-keyword">public</span> <span class="keyword hljs-keyword">void</span> <span class="title hljs-title">writeExternal</span><span class="params hljs-params">(ObjectOutput objectOutput)</span> <span class="keyword hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string hljs-string">"writeExternal()"</span>);</span><br><span class="line">    objectOutput.writeInt(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta hljs-meta">@Override</span></span><br><span class="line"><span class="function hljs-function"><span class="keyword hljs-keyword">public</span> <span class="keyword hljs-keyword">void</span> <span class="title hljs-title">readExternal</span><span class="params hljs-params">(ObjectInput objectInput)</span> <span class="keyword hljs-keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string hljs-string">"readExternal()"</span>);</span><br><span class="line">    n = objectInput.readInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Externalizable的替代方法"><a href="#Externalizable的替代方法" class="headerlink" title="Externalizable的替代方法"></a>Externalizable的替代方法</h2><p>如果觉得Externalizable这样太麻烦的话，我们依然可以使用Serializable，不过需要添加两个方法。并遵循它们的特征签名<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function hljs-function"><span class="keyword hljs-keyword">private</span> <span class="keyword hljs-keyword">void</span> <span class="title hljs-title">writeObject</span><span class="params hljs-params">(ObjectOutputStream stream)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getStackTrace()[<span class="number hljs-number">1</span>].getMethodName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function hljs-function"><span class="keyword hljs-keyword">private</span> <span class="keyword hljs-keyword">void</span> <span class="title hljs-title">readObject</span><span class="params hljs-params">(ObjectInputStream stream)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getStackTrace()[<span class="number hljs-number">1</span>].getMethodName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>查看下源码就知道如果我们实现了这两个方法（虽然只是添加，就当他是实现吧），那么就不会走正常的序列化流程，而转为使用我们自己实现的。<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function hljs-function"><span class="keyword hljs-keyword">void</span> <span class="title hljs-title">invokeWriteObject</span><span class="params hljs-params">(Object var1, ObjectOutputStream var2)</span> <span class="keyword hljs-keyword">throws</span> IOException, UnsupportedOperationException </span>&#123;</span><br><span class="line">    <span class="keyword hljs-keyword">this</span>.requireInitialized();</span><br><span class="line">    <span class="keyword hljs-keyword">if</span> (<span class="keyword hljs-keyword">this</span>.writeObjectMethod != <span class="keyword hljs-keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword hljs-keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword hljs-keyword">this</span>.writeObjectMethod.invoke(var1, var2);</span><br><span class="line">        &#125; <span class="keyword hljs-keyword">catch</span> (InvocationTargetException var5) &#123;</span><br><span class="line">            Throwable var4 = var5.getTargetException();</span><br><span class="line">            <span class="keyword hljs-keyword">if</span> (var4 <span class="keyword hljs-keyword">instanceof</span> IOException) &#123;</span><br><span class="line">                <span class="keyword hljs-keyword">throw</span> (IOException)var4;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            throwMiscException(var4);</span><br><span class="line">        &#125; <span class="keyword hljs-keyword">catch</span> (IllegalAccessException var6) &#123;</span><br><span class="line">            <span class="keyword hljs-keyword">throw</span> <span class="keyword hljs-keyword">new</span> InternalError(var6);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword hljs-keyword">throw</span> <span class="keyword hljs-keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果我们自己实现的话实现方式和Externalizable一样<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function hljs-function"><span class="keyword hljs-keyword">private</span> <span class="keyword hljs-keyword">void</span> <span class="title hljs-title">writeObject</span><span class="params hljs-params">(ObjectOutputStream stream)</span> <span class="keyword hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    stream.writeInt(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function hljs-function"><span class="keyword hljs-keyword">private</span> <span class="keyword hljs-keyword">void</span> <span class="title hljs-title">readObject</span><span class="params hljs-params">(ObjectInputStream stream)</span> <span class="keyword hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    n = stream.readInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>序列化个人认为没有特别深入的必要，只要知道使用方法即可。</p>

    
    </div>
    
    
    <div class="columns is-mobile is-multiline article-nav">
        <span class="column is-12-mobile is-half-desktop  article-nav-prev">
            
            <a href="/2018/09/13/C-move-fun/">C++ move function</a>
            
        </span>
        <span class="column is-12-mobile is-half-desktop  article-nav-next">
            
            <a href="/2018/09/06/Kotlin-Constructor/">Kotlin Constructor</a>
            
        </span>
    </div>
    
</article>




    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2018 Star&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a
                        href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            
        </div>
    </div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        // plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
    moment.locale("default");
</script>



<script src="/js/script.js"></script>

    
</body>
</html>