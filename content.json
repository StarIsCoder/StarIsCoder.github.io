{"pages":[],"posts":[{"title":"Matrix&Camera","text":"最近在学习自定义view，先将学到了东西记录一下。 MatrixMatrix就是矩阵的意思，具体的数学原理已经还给老师了，因此只是记录使用方式。由于矩阵并不满足交换律，即：AB ≠ BA因此矩阵的方法都是成对的，用pre或者post作为前缀表示前乘或者后乘，这个前和后的意思就是将初始矩阵放在前还是后的意思。使用方法：12345Matrix matrix = new Matrix();matrix.preRotate(45);matrix.postTranslate(200, 0);canvas.setMatrix(matrix);canvas.drawBitmap(bitmap, 100, 100, paint); Matrix的强大之处在于可以完成一切的形变，而canvas只支持一部分的形变。并且Matrix可以根据前乘和后乘（绝对不是根据简单的pre和post）来决定形变的顺序。 Camera\bCamera顾名思义就是照相机，这是一个在三维坐标轴上处于z轴的一个相机，他的工作原理就是将三维模型投影在canvas，也就是我们实际看到的图形。插播一段它的坐标系。 View的坐标系:以屏幕左上方为原点。x轴左负右正，y轴上负下正。 Camera的坐标系:以屏幕左上方为原点，x轴左负右正,y轴上正下负，z轴内正外负。 如果我们直接调用camera的rotate方法的话，假设让它绕x轴旋转30度，由于camera是始终处于z轴上的，\b因此如果这时候投影的话，那么投影出来的图形并不是我们想要的效果，而是不对称且右边拉长的结果。解决办法就是在旋转之前先将图片移到原点。之后再移回来，不过代码中canvas的移动要反过来写，因为它是反向执行的。1234camera.rotateX(30);canvas.translate(centerX, centerY); camera.applyToCanvas(canvas); canvas.translate(-centerX, -centerY); 其余的一些调用api的就不写了，等用的时候一查就有了。","link":"/2018/08/28/Android-Matrix-Camera/"},{"title":"LinearLayout设置gravity不生效","text":"最近在学习Transition\b动画的时候，有个动画是将button从左上移到右下，代码其实很简单。1234TransitionManager.beginDelayedTransition(transitionContainer, ChangeBounds().setPathMotion(ArcMotion()).setDuration(1000))var params = button_view.layoutParams as FrameLayout.LayoutParamsparams.gravity = Gravity.BOTTOM or Gravity.RIGHTbutton_view.layoutParams = params 这边使用的是\bFrameLayout,最开始使用\b\bLinearLayout的时候修改gravity始终无效。后来意识到因为LinearLayout是或横向或纵向的布局，因此如果当它处于横向的情况时，只有top和bottom是有效的，因为横向的布局都依赖于\b子控件的个数。反之如果是\b纵向布局，\b只有right和left是有效的。","link":"/2018/08/28/Android-LinearLayout-set-gravity-not-working/"},{"title":"View的Measure&和Layout","text":"在自定义view的时候比较重要的就是三个方法。 onMeasure(int widthMeasureSpec, int heightMeasureSpec) onLayout(boolean changed, int left, int top, int right, int bottom) onDraw(Canvas canvas) onMeasureon\bMeasure方法是在view的measure方法中调用的。主要是控制控件的尺寸。12345678910111213141516public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; ...... if (cacheIndex &lt; 0 || sIgnoreMeasureCache) &#123; // measure ourselves, this should set the measured dimension flag back onMeasure(widthMeasureSpec, heightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; else &#123; long value = mMeasureCache.valueAt(cacheIndex); // Casting a long to int drops the high 32 bits, no mask needed setMeasuredDimensionRaw((int) (value &gt;&gt; 32), (int) value); mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; ...... 继续看onMeasure的实现，一直到最后一系列的调用就是给mMeasuredWidth和mMeasuredHeight赋值。1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125; 123456789101112protected final void setMeasuredDimension(int measuredWidth, int measuredHeight)&#123; boolean optical = isLayoutModeOptical(this); if (optical != isLayoutModeOptical(mParent)) &#123; Insets insets = getOpticalInsets(); int opticalWidth = insets.left + insets.right; int opticalHeight = insets.top + insets.bottom; measuredWidth += optical ? opticalWidth : -opticalWidth; measuredHeight += optical ? opticalHeight : -opticalHeight; &#125; setMeasuredDimensionRaw(measuredWidth, measuredHeight);&#125; 12345678910111213141516public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result;&#125; 插播一段：因为在调用measure方法的时候传入的两个参数widthMeasureSpec和heightMeasureSpec都是通过MeasureSpec构造出来的，因此这个类可以简单了解下。 这个measureSpec是一个32位int类型的数据，前两位表示mode，后30位表示size。因为他的掩码是11后面加30个零。例如getMode，掩码和measureSpec进行与运算，得到的一定是measureSpec的前两位，\b即mode值。也就是说根据mode值来设置返回不同的size。123456789private static final int MODE_MASK = 0x3 &lt;&lt; MODE_SHIFT;public static int getMode(int measureSpec) &#123; return (measureSpec &amp; MODE_MASK);&#125;public static int getSize(int measureSpec) &#123; return (measureSpec &amp; ~MODE_MASK);&#125; 因此如果复写onMeasure方法，能改动的变量也只有重新设置mMeasuredHeight和mMeasuredWidth。也就是调用setMeasuredDimension这个方法，将我们需要的height和width传进去即可。 onLayoutonLayout方法一样也是在layout()方法中调用的，作用是控制子控件的布局。因此view的onLayout方法是空的,因为只有\bViewGroup才有子控件。不过ViewGroup的\bonLayout方法也只是个抽象类，实现的地方还是在ViewGroup的子类中。12@Override protected abstract void onLayout(boolean changed,int l, int t, int r, int b); 例如LinearLayout的onLayout方法,根据orientation进行不同的布局排版。1234567protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; if (mOrientation == VERTICAL) &#123; layoutVertical(l, t, r, b); &#125; else &#123; layoutHorizontal(l, t, r, b); &#125;&#125; 之前碰到一个坑就是在vertical的LinearLayout情况下gravity的top和bottom不生效，当时理解为因为纵向线形布局的高度都是根据子view来决定的，这边看下源码印象更深刻,以vertical为例。1234567891011121314151617181920212223for (int i = 0; i &lt; count; i++) &#123; ...... switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123; case Gravity.CENTER_HORIZONTAL: childLeft = paddingLeft + ((childSpace - childWidth) / 2) + lp.leftMargin - lp.rightMargin; break; case Gravity.RIGHT: childLeft = childRight - childWidth - lp.rightMargin; break; case Gravity.LEFT: default: childLeft = paddingLeft + lp.leftMargin; break; &#125; ......&#125; 在layoutVertical中对子view的排版只有RIGHT和LEFT两个属性，并没有对TOP和BOTTOM处理。 其余还有些padding和margin等balabala各种属性要考虑到其中就不赘述了。 自定义Layout属性在学习写自定义Layout的时候，顺便练习了下自定义属性，主要以下几步 新建attrs.xml,declare-styleable的name是自定义的布局名称，attr的name和format都自己定义 1234567&lt;resources&gt; &lt;declare-styleable name=\"MyLayout\"&gt; &lt;attr name=\"isVertical\" format=\"boolean\" /&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 在布局文件中设置该属性 123456&lt;MyLayout ....... android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:isVertical=\"true\" tools:context=\".MainActivity\"&gt; 在该类初始化的时候获取属性值 123var isVertical: Boolean = falsevar t = context?.obtainStyledAttributes(attrs, R.styleable.MyLayout)isVertical = t!!.getBoolean(R.styleable.MyLayout_isVertical, false)","link":"/2018/09/05/Android-Measure-Layout/"},{"title":"Modify shape attributes in code","text":"123((GradientDrawable)(ContextCompat.getDrawable(context, R.drawable.pen_color_red))) .setSize(getResources().getDimensionPixelSize(R.dimen.wb_native_buttons_size_newui), getResources().getDimensionPixelSize(R.dimen.wb_native_buttons_size)); convert drawable to GradientDrawable,and invoke setSize or setStroke and so on.","link":"/2018/07/26/Android-Modify-shape-attributes/"},{"title":"区分tablet和mobile","text":"最近项目上UE有个需求是增加一个按钮切换横竖屏，当然很容易想到使用1activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE); 传入的值一般有如下，按字面意思理解即可：1234SCREEN_ORIENTATION_PORTRAITSCREEN_ORIENTATION_LANDSCAPESCREEN_ORIENTATION_REVERSE_PORTRAITSCREEN_ORIENTATION_LANDSCAPE \b但是这样设置有个问题，那就是手动设置了横竖屏之后系统的AutoRotate失效了。有一种workaround就是手动去处理转屏事件。\b加一个内部类继承OrientationEventListener。只要底层重力传感器的值发生变化就会回调这个类中的onOrientationChanged方法。之后根据\b上报的orientation值和一些flag进行横竖屏处理。1234567891011private class IncallOrientationListener extends OrientationEventListener &#123; public IncallOrientationListener(Context context) &#123; super(context); &#125; @Override public void onOrientationChanged(int orientation) &#123; //do anything what we want orientationUtils.onOrientationChanged(getApplicationContext(), orientation); &#125; &#125; \b然而在上一次\bGT的时候发现平板下横竖屏全反了，原因是平板是横着的时候oreintation为0，这时候如果设置SCREEN_ORIENTATION_PORTRAIT就会有问题，当转屏之后又设置了SCREEN_ORIENTATION_LANDSCAPE。也就是说对于横着的平板和\b手机相比应该走完全相反的逻辑。那么就需要区分平板和手机了，官方似乎没有相关文档，但是根据以前我处理分屏下布局\b的bug，系统应该是根据长宽的大小比较来决定是使用port文件夹还是land文件夹下的布局。这个在stackoverflow上的workaround123public static boolean isTablet(Context context) &#123; return (context.getResources().getConfiguration().screenLayout &amp; Configuration.SCREENLAYOUT_SIZE_MASK) &gt;= Configuration.SCREENLAYOUT_SIZE_LARGE; &#125; 其实我个人\b认为通过长宽来判断应该设置横屏还是竖屏更合理一点。因为有的平板就是放大版的手机，这种平板其实就应该走手机的逻辑。用WindowManagerService来获取屏幕的宽高。1234567WindowManager wm = (WindowManager) getSystemService(Context.WINDOW_SERVICE);DisplayMetrics metrics = new DisplayMetrics();wm.getDefaultDisplay().getMetrics(metrics);int heightPixels = metrics.heightPixels;Log.d(TAG, \"heightPixels :\" + heightPixels);int widthPixels = metrics.widthPixels;Log.d(TAG, \"widthPixels :\" + widthPixels); 123Result:heightPixels :1440 widthPixels :2560 //横屏heightPixels :2560 widthPixels :1440 //竖屏","link":"/2018/08/26/Android-区分tablet和mobile/"},{"title":"PopupWindow show at location","text":"Recently,UE Team has updated some features.One of them is click on the button,and show PopupWindow right above the button.The point is can’t use hardcode because different devices has different resolution. So the best way is get the location in the window.There is method named getLocationInWindow(View view) in View.java.All we have to do is invoke the method by the button and pass an array.This array will store two value,X coordinate and Y coordinate.1234int[] viewLocation = new int[2];view.getLocationInWindow(viewLocation);//X coordinate viewLocation[0]//Y coordinate viewLocation[1]","link":"/2018/07/24/Android-ShowPopupAtLocation/"},{"title":"Constructor&Destructor","text":"构造函数构造函数的定义就不写了，直接看下例子,这里的构造函数中初始化了number\b这个变量。 插播一段：这里使用了ifndef和define来防止多重包含。即使多个文件include了这个头文件也只会包含一次。123456789101112131415161718192021#ifndef Stock00_h#define Stock00_hclass Stock &#123;private: int number_;public: void display(); void set(int); Stock(int);&#125;;void Stock::display()&#123; std::cout &lt;&lt; number_ &lt;&lt; std::endl;&#125;Stock::Stock(int number)&#123; number_ = number;&#125;#endif /* Stock00_h */ 如何使用：1234567int main(int argc, const char * argv[]) &#123; Stock stock1(100); //隐式 Stock stock2 = Stock(100); //显式 Stock stock3 &#123;100&#125;; //类似初始化列表的情况 stock1.display(); return 0;&#125; Warning: 如果该类定义了构造函数，那么当实例化该类的时候则必须调用它的构造方法 构造函数的参数名不能与类成员相同。一种做法是在数据成员前面加上m_前缀，还有一种做法是在\b成员名称后面加后缀_。 析构函数析构函数是和构造函数对应的，一个是创建过程中调用，析构函数则是在对象销毁时调用的，不过大部分情况都是由系统自己调用，很少有显式调用的情况。析构函数不包含任何参数。 静态存储类对象：程序结束时调用。 自动存储类对象：函数结束时调用。 new创建的对象：调用delete\b来释放内存时调用。 const成员函数如果定义了一个const的类，\b调用该类的非const方法则会报错，因为不能保证调用的对象不被修改：1234567const Stock stock1 &#123;100&#125;;stock1.display();void Stock::display()&#123; std::cout &lt;&lt; number_ &lt;&lt; std::endl;&#125; 解决方式在函数最后加上const关键字:123456void display() const;void Stock::display() const&#123; std::cout &lt;&lt; number_ &lt;&lt; std::endl;&#125; this指针之前在尝试写成员变量的get/set方法时，发现在c++中this并不代表一个类，而是一个类的指针。并且可以表示隐式的访问，12345678910\bstock1.topval(stock2);Stock &amp; Stock::topval(Stock &amp;s)&#123; if (this-&gt;number_ &gt; s.number_) &#123; return *this; &#125; else &#123; return s; &#125;&#125; 可以看到在这个函数中，this表示stock1。 基于C++ Primer plus第十章","link":"/2018/09/03/C-Constructor-Destructor/"},{"title":"C++ 深入函数","text":"C++内联函数传统函数：当我们调用函数的时候，其实是将该指令的内存地址保存下来，并将函数参数复制到堆栈。当函数运行完之后再跳回去。这样来回跳跃会加大开销。因此还有另一种函数，叫做内联函数。 内联函数：简单来说就是将函数的代码替换函数调用，这样就不用跳到其他地方执行，但是如果有10个地方调用了这个函数，那么\b就会有10个函数代码的拷贝。 在函数声明前加上inline 在函数定义前加上inline Warning: 如果内联函数过大或者调用了自己（不支持递归），那么编译器不会将其作为内联函数。并不是所有的编译器启用了这个特性。 内联与宏inline关键字是C++新增的特性。C语言则使用#define。但C语言中时、是通过文本替换而不是传递参数。123#define SQUARE(X) X*Xa = SQUARE(5 + 1); // a = 5 + 1 * 5 + 1 not a = 6 * 6 引用变量基本概念：引用是已定义的变量的别名。使用&amp;符号表示引用。12int i;int &amp; another = i;//alias for i int&amp;表示指向int的引用，上述表示i和another指向相同的值和内存单元。如果改变了another，那么i也会改变。引用其实就是另一个变量的\b完美复制品，除了名称不一样其他一模一样，表现在指针中则是：1int &amp; i = rats; 等同于1int * const pr = &amp;rats; 引用和指针最大的区别就是引用在声明的时候必须初始化。 引用用作函数参数也就是将某种类型的引用作为参数传入函数。在代码方面，如果使用\bvalue传递的话会有一个变量的copy，而引用的则不会有两个变量，只会有两个名称。之后在函数中不管怎么处理都只是在操作这个copy而没有改变他的原始值。 如果我们\b\b定义了一个函数的参数是引用，那么则必须传一个变量进去，传入表达式则是不规范的。例如：12void square(int &amp; i);square(x + 3);// INVALID 当然有的编译器不会报错，只是弹一个warning出来，那是因为如果实参和引用参数不匹配的话就会生成临时变量。并且只有当参数是const引用时才会这么做。如果参数是const类型，那么在以下情况会生成临时变量 实参的类型正确，但不是左值。 实参的类型不正确，但可以转换为正确的类型。 左值其实就是指处于等号左边的值，那么什么样的值可以放等号左边呢，自然是变量，引用等等。像字面常量，表达式则都属于非左值。如下例：1234double refcube(const double &amp; ra)&#123; return ra * ra * ra;&#125; 12345double side = 3.0;long edge = 5Ldouble c1 = refcube(edge);//临时变量，因为edge类型与参数不匹配double c2 = refcube(7.0);//临时变量，非左值，\b字面常量double c3 = refcube(side + 3.0);//临时变量，\b非左值，表达式 何时使用引用参数 函数中的数据对象需要被修改 数据较大时需要提高程序的运行速度。 第二个原因有点类似于指针，那么什么时候使用指针\b，什么\b时候使用引用呢： 如果数据对象很小，则按值传递。 如果数据对象是数组，那么使用指针，同时也是唯一的选择。 如果是较大的数据结构则使用指针或引用。 如果是类对象，则使用const引用。 默认参数也很简单，就是在函数定义的时候给参数一个默认值。1char * open(int n = 1) 但是有个规矩那就是\b必须从右向左添加默认值。 函数重载其实就是同一个函数，但是参数类型或者数量不同叫做函数重载。在java中是必须严格按照参数类型或者\b数量来调用函数的，但是在c++中如果调用的函数不与任何函数原型匹配，那么就会尝试使用标准类型转换强制进行匹配。12345678910void test(int i = 1);int main(int argc, const char * argv[]) &#123; test(2.2); return 0;&#125;void test (int i)&#123; cout &lt;&lt; i &lt;&lt; endl;&#125; 1Result:2 而关于const也可以用于重载函数，不过只有在修饰的参数是引用或者指针的时候才可以。 函数模版简单来说就是使用泛型来定义函数，编译器会\b按照\b模版创建对应的函数，例如有个函数的作用是交换传入的两个参数，那么不管传入是int还是double都可以使用同一个函数模版。123456789101112131415161718192021222324template &lt;typename T&gt;void Swap(T &amp;a,T &amp;b);using namespace std;int main(int argc, const char * argv[]) &#123; int i = 10; int j = 30; Swap(i,j); cout &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; j &lt;&lt; endl; double d1 = 2.2; double d2 = 4.4; Swap(d1, d2); cout &lt;&lt; d1 &lt;&lt; endl; cout &lt;&lt; d2 &lt;&lt; endl; return 0;&#125;template &lt;typename T&gt;void Swap(T &amp;a,T &amp;b) &#123; T temp; temp = a; a = b; b = temp;&#125;","link":"/2018/08/23/C-Inline-Reference/"},{"title":"C++指针笔记","text":"基本概念指针也是一种变量，特殊之处在于它存储的是变量的地址，如下：1234567int main(int argc, const char * argv[]) &#123; int i = 6; //assign the address of i to pointer int *pointer = &amp;i; int *pointer1 = new int; return 0;&#125; 操作符*被叫做间接值或者\b解除应用 Warning: 一定要在对指针使用*之前，将指针初始化为一个确定的、适当的地址 运算符new在C中，使用malloc来分配内存，在c++中则使用new关键字。为一个数据对象获得并制定分配内存的通用格式：_typeName * pointer_name = new typeName;_ 一旦我们不需要该指针，应该使用delete关键字将该指针释放，new和delete必须成对出现，否则会发生memory leak。123int *ps = new int;...delete ps; 这将释放ps指针所指向的内存，但不会删除ps本身，也就是说可以继续将ps指向其他地址。 动态数组使用new关键字来创建动态数组，并且返回的是该数组第一个元素的地址，如果想要获得第二个元素的地址，则需要将该指针加1，如下：123456789101112int main(int argc, const char * argv[]) &#123; // insert code here... int *array = new int[10]; array[0] = 1; array[1] = 3; cout &lt;&lt; *array; cout &lt;&lt; endl; array = array + 1; cout &lt;&lt; *array; cout &lt;&lt; endl; return 0;&#125; Result:1213 动态结构结构体同样可以使用new关键字。不同的是无法使用句点运算符，取而代之的是-&gt;运算符，如下：12345678910111213struct things &#123; int price; int sum;&#125;;int main(int argc, const char * argv[]) &#123; // insert code here... things t = &#123;3,18&#125;; things * tpt = &amp;t; //things * tpt = new things; cout &lt;&lt; tpt-&gt;price; cout &lt;&lt; endl; return 0;&#125; Result:13 指针与字符串一般来说如果给cout提供一个指针的话，他将打印地址，但是如果指针的类型为char ，那么cout的指针其实指向的是char的第一个字符的地址，并且会依次往后直到结束符。如下：12345678910int main(int argc, const char * argv[]) &#123; char * c = \"dog\"; cout &lt;&lt; \"c :\" &lt;&lt; c; cout&lt;&lt; endl; cout &lt;&lt;\"*c :\" &lt;&lt; *c; cout &lt;&lt; endl; cout &lt;&lt;\"第一个字符的地址 ：\" &lt;&lt; (int*)c; cout &lt;&lt; endl; return 0;&#125; 123c :dog*c :d第一个字符的地址 ：0x100001edc 管理内存的三种方式 自动存储在函数内部定义的常规变量使用自动存储空间，被称为自动变量，也就是说在函数\b执行完成之后会自动销毁。自动变量存储在栈中，采用先进后出的形式。 静态存储变量成为静态的方式有两种，一是在函数外面定义；二是使用static关键字。 动态存储使用new和delete管理内存，它们管理了一个内存池，被成为自由存储空间或堆，这个内存池和静态比变量以及自动变量的内存是分开的。 目前为\bC++ Primer Plus的第四章。","link":"/2018/08/06/C-Pointer-Note/"},{"title":"函数与数组","text":"单个数组作为函数的参数C++中将数组名看成是第一个元素的地址。如下：12int cookies[8] = &#123;1,2,4,8,16,32,64,128&#125;;cout &lt;&lt; cookies; 10x7ffeefbff540 但是该规矩有一个特例，就是在函数原型中，int *arr和int arr[]表示同一个意思。如下：1int sum_arr(int *arr,int n); 1int sum_arr(int arr[],int n); 也就是说在这个特例中将数组作为了参数，其实是将数组第一个元素的地址传递给了函数，而并没有传递数组的内容。 总结：传递常规变量时，函数将使用该变量的拷贝；但传递数组时，函数将使用原来的数组。其实传递数组时也传递了一个值，这个值被赋予给了\b一个新变量，也即是地址。这么做的好处是能节省开支，如果该数组很大，那么要对它进行拷贝则费时费力。 Warning :为将数组类型和元素数量告诉数组处理函数，请通过两个不同的参数来传递它们：12void fillArray(int arr[], int size); //goodvoid fillArray(int arr[size]); //bad 如果在某个函数中，所传入的数组不希望被修改，则可以使用const关键字修饰该数组。这表示指针arr指向的是常量数据，在该函数中不能使用ar修改该数据，当然，这并不是说原始数组必须是常量。如下：1void show_array(const int arr[], int n); 多个数组作为函数的参数实际上我们也可以通过传入两个地址来表示数组在这两个地址的区间内。12345678910111213141516171819using namespace std;int sum_arr(int *start,int *end);int main(int argc, const char * argv[]) &#123; int cookies[8] = &#123;1,2,4,8,16,32,64,128&#125;; int total = sum_arr(cookies, cookies + 8); int wrongTotal = sum_arr(cookies, cookies + 9); cout &lt;&lt; total; cout &lt;&lt; endl; cout &lt;&lt; wrongTotal; &#125;int sum_arr(int start[], int end[])&#123; int sum = 0; int *pt; for (pt = start; pt != end; pt++) &#123; sum = sum + *pt; &#125; return sum;&#125; 123Result:255-272632185 即使超出数组也不会报错，因为c++中只在初始化的时候检查数组是否越界。 函数\b和字符串将字符串作为参数来传递的时候，同样传递的是第一个字符的地址，字符串有内置的结束字符。因此想要判断字符串是否读取完毕则可以使用*str是否为0。如下：123456789101112131415161718using namespace std;int count(char * str);int main(int argc, const char * argv[]) &#123; char * str = \"xingxing\"; int g = count(str); cout &lt;&lt; g;&#125;int count(char * str)&#123; int count = 0; while (*str) &#123; if (*str == 'g') &#123; count++; &#125; str++; &#125; return count;&#125; 函数和结构体函数中使用结构体比较简单，将结构体当作一个对象来使用就可以了。不赘述。 函数指针C++中函数也有地址，函数的地址是存储其机器语言代码的内存的开始地址，有时候会将函数地址作为参数传给另一个函数。 获取函数地址使用函数名且不带任何参数就是使用函数的地址。例如test()是一个函数，那么test就是该函数的地址。12show(test()) //传递test函数的返回值show(test) //传递test函数的地址 声明函数指针声明一个函数指针就是将该函数原型中的函数名替换为指针名即可。123int test(int); //原型int (*pf)(int); //函数指针声明pf = test; //函数指针赋值 如果使用该函数指针来调用函数的话则可以这样：12pf(5);(*pf)(5); \bC++PrimerPlus\b习题7.6123456789101112131415161718192021222324252627282930313233343536373839void Fill_array(double [], int size);void Show_array(double [], int size);void Reverse_array(double [], int size);using namespace std;int main(int argc, const char * argv[]) &#123; int max = 5; double array[max]; Fill_array(array, max); Show_array(array,max); Reverse_array(array, max); Show_array(array, max); return 0;&#125;void Fill_array(double arr[], int size)&#123; for (int i = 0; i &lt; size; i++) &#123; cout &lt;&lt; \"Enter double :\"; cin &gt;&gt; arr[i]; &#125;&#125;void Show_array(double arr[], int size)&#123; for (int i = 0; i &lt; size; i++) &#123; cout &lt;&lt; arr[i]; cout &lt;&lt; endl; &#125;&#125;void Reverse_array(double arr[], int size)&#123; for (int i = 0; i &lt; size / 2 ; i++) &#123; double tmp = arr[i]; arr[i] = arr[size - i -1]; arr[size - i -1] = tmp; &#125;&#125; 7.101234567891011121314151617double calculate(double,double,double (*pf)(double,double));double add(double,double);int main(int argc, const char * argv[]) &#123; double d = calculate(2.2,2.8,add); cout &lt;&lt; d &lt;&lt; endl; return 0;&#125;double add(double x,double y)&#123; return x + y;&#125;double calculate(double i,double j,double (*pf)(double,double))&#123; return pf(i,j);&#125; \b 基于C++ Primer plus第七章。","link":"/2018/08/16/C-function-array/"},{"title":"C++ move function","text":"最近在查看别人搭的框架时，看到在传值的时候使用了std::move。因此学习一下这个函数的使用。首先google查看官方解释： In particular, std::move produces an xvalue expression that identifies its argument t. It is exactly equivalent to a static_cast to an rvalue reference type. 简单来说就是将一个值转化为右值。目的是为了提升效率，减少拷贝的数量。也就是进行深拷贝。 右值那么右值又是什么？还是查看微软的官方解释吧。 Every C++ expression is either an lvalue or an rvalue. An lvalue refers to an object that persists beyond a single expression. You can think of an lvalue as an object that has a name. All variables, including nonmodifiable (const) variables, are lvalues. An rvalue is a temporary value that does not persist beyond the expression that uses it. 在c++中，表达式是要么左值要么右值，左值表示他对一个对象的应用远远超过了一个表达式（可以忽略），其实也可以把左值看成一个有名字的对象。所有的变量，常量都是左值。右值是一个临时变量，并不会比表达式保存的更久。 这个左和右是相对于等于号的。等于号左边必然是一个变量，右边是一个表示式或者是一个临时变量。感觉还是不太好用语言来解释这玩意。贴一段官方的sample。12345678910111213141516// Correct usage: the variable i is an lvalue. i = 7; // Incorrect usage: The left operand must be an lvalue (C2106). 7 = i; // C2106 j * 4 = 7; // C2106 // Correct usage: the dereferenced pointer is an lvalue. *p = i; const int ci = 7; // Incorrect usage: the variable is a non-modifiable lvalue (C3892). ci = 9; // C3892 // Correct usage: the conditional operator returns an lvalue. ((i &lt; 3) ? i : j) = 7; move还是看回move函数，比如在写交换函数的时候我们通常这么写。123456789101112131415void swap(string &amp;,string &amp;);int main(int argc, const char * argv[]) &#123; string x = \"abc\"; string y = \"wang\"; swap(x, y); cout &lt;&lt; x &lt;&lt; endl; cout &lt;&lt; y &lt;&lt; endl; return 0;&#125;void swap(string &amp; x,string &amp; y)&#123; string tmp = x; x = y; y = tmp;&#125; 这样的话其实在执行交换的过程中会产生三个copy的对象，会影响性能。不过有时候我们传递了某个值之后就不再不需要他了，如果留着一个拷贝的话也会占用空间，因此可以使用move函数来表示这个值以后没用了，已经传走了。123456void swap(string &amp; x,string &amp; y)&#123; string tmp = move(x); x = move(y); y = move(tmp);&#125; 这样就不会有三分拷贝，而是值的转移。不过这么写似乎看不出值已经传走了。用个vector试一下12345678910111213141516int main(int argc, const char * argv[]) &#123; vector&lt;string&gt; v; string str = \"test\"; v.push_back(str); cout &lt;&lt; \"str :\" &lt;&lt; str &lt;&lt; endl; for (int i = 0; i&lt;v.size(); i++) &#123; cout &lt;&lt; \"vector\" &lt;&lt; i &lt;&lt; \" :\" &lt;&lt; v[i] &lt;&lt; endl; &#125; cout &lt;&lt; \"after move\" &lt;&lt;endl; v.push_back(move(str)); cout &lt;&lt; \"str :\" &lt;&lt; str &lt;&lt; endl; for (int i = 0; i&lt;v.size(); i++) &#123; cout &lt;&lt; \"vector\" &lt;&lt; i &lt;&lt; \" :\" &lt;&lt; v[i] &lt;&lt; endl; &#125; return 0;&#125; 1234567Result:str :testvector0 :testafter movestr :vector0 :testvector1 :test 可以看到str已经为空并且作为右值存在了vector中。 总结并不是只在传递值的时候可以用move，更关键的是当你想把某个左值转化成右值的时候需要用到这个函数。 因为查看该函数的源码就是将传入的值转为\b右值引用。12345move(_Tp&amp;&amp; __t) _NOEXCEPT&#123; typedef typename remove_reference&lt;_Tp&gt;::type _Up; return static_cast&lt;_Up&amp;&amp;&gt;(__t);&#125;","link":"/2018/09/13/C-move-fun/"},{"title":"Java_Container","text":"Basic Concept容器是用来存储对象的，通常有两种 Collection: 一个独立的序列，例如List，Set等 Map:一种键-值对. List、Set、Map的区别Now check the different result on the demo.123456789101112131415161718192021222324252627public class PrintingContainers &#123; public static void main(String[] args) &#123; System.out.println(fill(new ArrayList&lt;&gt;())); System.out.println(fill(new LinkedList&lt;&gt;())); System.out.println(fill(new HashSet&lt;&gt;())); System.out.println(fill(new TreeSet&lt;&gt;())); System.out.println(fill(new LinkedHashSet&lt;&gt;())); System.out.println(fill(new HashMap&lt;&gt;())); System.out.println(fill(new TreeMap&lt;&gt;())); System.out.println(fill(new LinkedHashMap&lt;&gt;())); &#125; static Collection fill(Collection&lt;String&gt; collection) &#123; collection.add(\"dog\"); collection.add(\"cat\"); collection.add(\"rat\"); collection.add(\"dog\"); return collection; &#125; static Map fill(Map&lt;String, String&gt; map) &#123; map.put(\"rat\", \"Tom\"); map.put(\"cat\", \"Jerry\"); return map; &#125; &#125; Result :12345678[dog, cat, rat, dog][dog, cat, rat, dog][rat, cat, dog][cat, dog, rat][dog, cat, rat]&#123;rat=Tom, cat=Jerry&#125;&#123;cat=Jerry, rat=Tom&#125;&#123;rat=Tom, cat=Jerry&#125; List ArrayList: 适合查询，不适合插入和删除元素。 LinkedList : 按照添加的顺序存储元素，常用于频繁的插入和删除元素。 Practice For List: Create a single linked List.User iterator to insert or remove elements12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class SingleListDemo &#123; public static void main(String[] args) &#123; SList&lt;String&gt; list = new SList&lt;&gt;(); SListIterator iterator = list.iterator(); iterator.insert(\"wang\"); System.out.println(list); iterator.insert(\"shen\"); System.out.println(list); iterator.insert(\"xing\"); System.out.println(list); SListIterator iterator1 = list.iterator(); iterator1.remove(); System.out.println(list); &#125; &#125; class SList&lt;E&gt; &#123; Link&lt;E&gt; head = new Link&lt;&gt;(null); public SListIterator iterator() &#123; return new SListIterator&lt;E&gt;(head); &#125; @Override public String toString() &#123; if (head.next == null) &#123; return \"[]\"; &#125; else &#123; System.out.print(\"[\"); StringBuilder stringBuilder = new StringBuilder(); SListIterator iterator = this.iterator(); while (iterator.hasNext()) &#123; stringBuilder.append(iterator.next() + (iterator.hasNext() ? \",\" : \"\")); &#125; return stringBuilder + \"]\"; &#125; &#125; &#125; class Link&lt;E&gt; &#123; E e; Link&lt;E&gt; next; public Link(E e) &#123; this.e = e; &#125; public Link(E e, Link&lt;E&gt; next) &#123; this.e = e; this.next = next; &#125; @Override public String toString() &#123; return e != null ? e.toString() : null; &#125; &#125; class SListIterator&lt;E&gt; &#123; Link&lt;E&gt; current; public SListIterator(Link&lt;E&gt; current) &#123; this.current = current; &#125; public boolean hasNext() &#123; return current.next != null; &#125; public void insert(E e) &#123; current.next = new Link&lt;&gt;(e); current = current.next; &#125; public void remove() &#123; if (current.next != null) current.next = current.next.next; &#125; public Link&lt;E&gt; next() &#123; current = current.next; return current; &#125; &#125; Set HashSet: 获取元素最快的一种 TreeSet: 降序的方式存储元素 LinkedHashSet : 根据添加的顺序存储元素 SortedSet: 由TreeSet实现的接口 Practice:Create a SortedSet ,Using LinkerList as an underlying implementation12345678910111213141516171819202122232425262728293031323334353637383940414243public class MySortedSetDemo &#123; public static void main(String[] args) &#123; MySortedSet&lt;Integer&gt; integerMySortedSet = new MySortedSet&lt;&gt;(); integerMySortedSet.add(6); integerMySortedSet.add(8); integerMySortedSet.add(2); integerMySortedSet.add(5); integerMySortedSet.add(2); integerMySortedSet.add(7); System.out.println(integerMySortedSet); MySortedSet&lt;String&gt; stringMySortedSet = new MySortedSet&lt;&gt;(); stringMySortedSet.add(\"wang\"); stringMySortedSet.add(\"shen\"); stringMySortedSet.add(\"xing\"); stringMySortedSet.add(\"is\"); stringMySortedSet.add(\"good\"); stringMySortedSet.add(\"is\"); stringMySortedSet.add(\"cool\"); System.out.println(stringMySortedSet); &#125; &#125; class MySortedSet&lt;E&gt; extends LinkedList&lt;E&gt; &#123; public int compare(E e1, E e2) &#123; System.out.println(e1.hashCode()); System.out.println(e2.hashCode()); int result = e1.hashCode() - e2.hashCode(); return Integer.compare(result, 0); &#125; public boolean add(E e) &#123; if (!this.contains(e)) &#123; Iterator&lt;E&gt; iterator = this.iterator(); int index = 0; while (iterator.hasNext()) &#123; if (compare(iterator.next(), e) &lt; 1) &#123; index++; &#125; &#125; add(index, e); return true; &#125; return false; &#125; &#125; Map HashMap: 最快的找到元素的方式 TreeMap:降序方式存储，且是唯一带有submap方法的Map，可以返回一个子树 LinkerHashMap: 按照添加的顺序存储 Something about Array.asList 123List&lt;Integer&gt; list = Arrays.asList(1,2,3); list.add(4);//Runtime error Because the array cannot be resized Let’s check the source code of Array.asList. It will return a fixed-size list by the specific array.123public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a); &#125; 散列与散列码由于线性搜索的速度相当慢，因此在HashMap中采用了散列码来取代线性搜索。它是一个代表对象的int值。hashCode()属于Object中的方法，因此适用于所有的java对象。HashMap就是通过hashCode来进行查询的。下面是将Groundhog和Prediction联系起来的demo：123456789101112131415161718192021222324252627282930313233343536public class Prediction &#123; private static Random random = new Random(47); private boolean shadow = random.nextDouble() &gt; 0.5; @Override public String toString() &#123; if (shadow) &#123; return \"Six more \"; &#125; else &#123; return \"early spring\"; &#125; &#125;&#125;public class Groundhog &#123; protected int number; public Groundhog(int number) &#123; this.number = number; &#125; @Override public String toString() &#123; return \"Groundhog #\" + number; &#125;&#125;public static &lt;T extends Groundhog&gt; void detectSpring(Class&lt;T&gt; type) throws Exception &#123; Constructor&lt;T&gt; ghog = type.getConstructor(int.class); Map&lt;Groundhog, Prediction&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; map.put(ghog.newInstance(i), new Prediction()); &#125; System.out.println(\"map = \" + map); Groundhog gh = ghog.newInstance(3); if (map.containsKey(gh)) &#123; System.out.println(map.get(gh)); &#125; &#125; 结果是找不到该key，原因很简单，这两个根本不是同一个类当然是查不到的，而它的查找方式就是在一个node中查找是否包含某个对象的hashcode，object的默认hashcode是和地址相关的。而想要让他们联系起来则需要覆写hashcode方法和equals方法。修改GroundDog12345678910111213141516171819202122public class Groundhog &#123; protected int number; public Groundhog(int number) &#123; this.number = number; &#125; @Override public String toString() &#123; return \"Groundhog #\" + number; &#125; @Override public boolean equals(Object o) &#123; return number == ((Groundhog) o).number; &#125; @Override public int hashCode() &#123; return number; &#125;&#125; 那么为什么也要覆写equals方法呢，因为HashMap中覆写了equals方法，是根据key来判断是否相同的1234567891011121314public final boolean equals(Object var1) &#123; if (var1 == this) &#123; return true; &#125; else &#123; if (var1 instanceof Entry) &#123; Entry var2 = (Entry)var1; if (Objects.equals(this.key, var2.getKey()) &amp;&amp; Objects.equals(this.value, var2.getValue())) &#123; return true; &#125; &#125; return false; &#125; &#125; 创建一个新的Map：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class SlowMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; &#123; private List&lt;K&gt; keys = new ArrayList&lt;&gt;(); private List&lt;V&gt; values = new ArrayList&lt;&gt;(); public V put(K key, V value) &#123; V oldValue = get(key); if (!keys.contains(key)) &#123; keys.add(key); values.add(value); &#125; else &#123; values.set(keys.indexOf(value), value); &#125; return oldValue; &#125; public V get(Object key) &#123; if (!keys.contains(key)) return null; else return values.get(keys.indexOf(key)); &#125; @Override public Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet() &#123; Set&lt;Map.Entry&lt;K, V&gt;&gt; set = new HashSet&lt;&gt;(); Iterator&lt;K&gt; ki = keys.iterator(); Iterator&lt;V&gt; vi = values.iterator(); while (ki.hasNext()) &#123; set.add(new MapEntry&lt;K, V&gt;(ki.next(), vi.next())); &#125; return null; &#125;&#125;class MapEntry&lt;K, V&gt; implements Map.Entry&lt;K, V&gt; &#123; private K key; private V value; public MapEntry(K key, V value) &#123; this.key = key; this.value = value; &#125; @Override public K getKey() &#123; return key; &#125; @Override public V getValue() &#123; return value; &#125; @Override public V setValue(V v) &#123; V oldValue = value; value = v; return oldValue; &#125;&#125; 这个简陋的map问题在于对键的保存是线性，只能挨个匹配，这样是非常慢的，那么HashMap是如何优化的呢，其实HashMap的数据结构是数组加单向链表的形式。将hashcode的hash值（就是一个转换的方法）作取模运算，结果作为数组的索引值index，而数组的元素是单项链表，挨个add。当我们需要get的时候则先通过hashcode的hash值作取模运算得到index。然后再在取得链表中挨个配对。简单实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758SimpleHashMap.javapublic class SimpleHashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; &#123; static final int SIZE = 997; LinkedList&lt;MapEntry&lt;K, V&gt;&gt;[] buckets = new LinkedList[SIZE]; @Override public Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet() &#123; Set&lt;Map.Entry&lt;K, V&gt;&gt; set = new HashSet&lt;&gt;(); for (LinkedList&lt;MapEntry&lt;K, V&gt;&gt; bucket : buckets) &#123; if (bucket == null) continue; for (MapEntry&lt;K, V&gt; pair : bucket) &#123; set.add(pair); &#125; &#125; return set; &#125; public V put(K key, V value) &#123; V oldValue = null; int index = Math.abs(key.hashCode()) % SIZE; if (buckets[index] == null) &#123; buckets[index] = new LinkedList&lt;&gt;(); &#125; MapEntry&lt;K, V&gt; pair = new MapEntry&lt;&gt;(key, value); LinkedList&lt;MapEntry&lt;K, V&gt;&gt; bucket = buckets[index]; ListIterator&lt;MapEntry&lt;K, V&gt;&gt; iterator = bucket.listIterator(); boolean hasfound = false; while (iterator.hasNext()) &#123; MapEntry&lt;K, V&gt; iPair = iterator.next(); if (iPair.getKey().equals(key)) &#123; oldValue = iPair.getValue(); hasfound = true; break; &#125; &#125; if (!hasfound) &#123; buckets[index].add(new MapEntry&lt;&gt;(key, value)); &#125; return oldValue; &#125; public V get(Object key) &#123; int index = Math.abs(key.hashCode()) % 997; for (MapEntry&lt;K, V&gt; iPair : buckets[index]) &#123; if (iPair.getKey() == key) return iPair.getValue(); &#125; return null; &#125; public static void main(String[] args) &#123; SimpleHashMap&lt;String, String&gt; map = new SimpleHashMap&lt;&gt;(); map.put(\"key0\", \"value0\"); map.put(\"key1\", \"value1\"); System.out.println(map); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142MapEntry.javapublic class MapEntry&lt;K, V&gt; implements Map.Entry&lt;K, V&gt; &#123; private K key; private V value; public MapEntry(K key, V value) &#123; this.key = key; this.value = value; &#125; @Override public K getKey() &#123; return key; &#125; @Override public V getValue() &#123; return value; &#125; @Override public V setValue(V v) &#123; V oldValue = value; value = v; return oldValue; &#125; @Override public boolean equals(Object o) &#123; if (!(o instanceof MapEntry)) return false; MapEntry me = (MapEntry) o; return (key == null ? me.getKey() == null : key.equals(me.getKey())) &amp;&amp; (value == null ? me.getValue() == null : value.equals(me.getValue())); &#125; @Override public int hashCode() &#123; return (key == null ? 0 : key.hashCode()) ^ (value == null ? 0 : value.hashCode()); &#125;&#125;","link":"/2018/08/04/Java-Container/"},{"title":"Java_NIO","text":"NIONIO有说是new io，也有说是non-blocking io，Whatever，nio是jdk 1.4之后引入的，目的是为了提高io速度，并且旧的io也已经被重新实现过了。记得以前还在odm的时候，经常会碰到ANR的原因是系统在执行io操作导致的，因此看来优化一下io还是有必要的。 Channel和Buffer之所以将channel和buffer放在一起是因为这两个是提高io速度的关键。旧的io形式是面向流的，例如经常用的InputStream和OutputSteam，比如在我们读取文件的时候，每次从流中读取一个字节，说的不恰当一点就是在文件和程序之间建立一个通道，并且是一个单向的通道，每一次把文件中的东西拷贝到程序中。 最致命的就是Stream的操作是阻塞的，在调用read方法的时候我们什么都做不了，只能等待它执行完了之后返回。 因此channel和buffer诞生了，这边结合Thinking in java中对channel和buffer的描述加以理解，把channel当成矿场，而把buffer当成矿场中的坑，那么我们在读取的时候其实是先把矿场里的煤矿丢进坑里，然后去拿坑里的煤矿，写数据的时候反之即可。这样形成的读写模式是非阻塞的。 1234567891011121314151617181920212223242526public static void main(String[] args) &#123; try &#123; //把stream转化成矿场（channel） FileChannel channel = new FileOutputStream(\"data.txt\").getChannel(); //把我们要加入的煤矿丢进坑（buffer），之后再把坑中的煤矿丢尽矿场 channel.write(ByteBuffer.wrap(\"First\".getBytes())); channel.close(); //same as above channel = new RandomAccessFile(\"data.txt\", \"rw\").getChannel(); //把矿车移到最后一个坑，然后继续挖坑填矿 channel.position(channel.size()); channel.write(ByteBuffer.wrap(\"Second\".getBytes())); channel.close(); channel = new FileInputStream(\"data.txt\").getChannel(); ByteBuffer buffer = ByteBuffer.allocate(1024); channel.read(buffer); buffer.flip(); while (buffer.hasRemaining()) &#123; System.out.print((char) buffer.get()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace() &#125;&#125; 再来看下buffer，这里用的字节buffer，当然也有FloatBuffer、 DoubleBuffer等等。刚才说过了buffer类似于矿场中的坑，但是我们不可能把整个矿场都挖出坑来，因此我们在使用buffer的时候需要分配一个大概的数量，也就是allocate方法。通过源码在allocate方法中它其实是返回了一个HeapByteBuffer，这是个继承ByteBuffer的类。1234567public static ByteBuffer allocate(int var0) &#123; if (var0 &lt; 0) &#123; throw new IllegalArgumentException(); &#125; else &#123; return new HeapByteBuffer(var0, var0); &#125;&#125; 通过一系列的调用最后它给三个属性赋值，分别是capacity、limit、position1234567891011121314151617Buffer(int var1, int var2, int var3, int var4) &#123; if (var4 &lt; 0) &#123; throw new IllegalArgumentException(\"Negative capacity: \" + var4); &#125; else &#123; this.capacity = var4; this.limit(var3); this.position(var2); if (var1 &gt;= 0) &#123; if (var1 &gt; var2) &#123; throw new IllegalArgumentException(\"mark &gt; position: (\" + var1 + \" &gt; \" + var2 + \")\"); &#125; this.mark = var1; &#125; &#125;&#125; capacity：一共有多少个坑 limit：最多有多少个坑 position：矿车在第几个坑 显然在刚开始分配的时候，capacity和limit是一样的，position是零。当我们执行了填写数据的代码之后，矿车肯定是在数据字节大小的位置上。例如我们要读的文件存着test，那么矿车这时候是在第四个位置上。BTW：这里从1开始计数是因为，在初始分配的时候就已经默认生成了一个坑，零号位的坑。那么这个时候如果我们想要从坑中拿煤矿的话，至少要将矿车移动到最前面。也就是flip方法的作用。看一下源码就知道它到底干了啥。 12345678public final Buffer flip() &#123; //把limit减少，提升效率 this.limit = this.position; //将矿车移到开头 this.position = 0; this.mark = -1; return this;&#125; buffer大部分的api都是对这三个属性操作的。例如clear方法。 123456public final Buffer clear() &#123; this.position = 0; this.limit = this.capacity; this.mark = -1; return this;&#125; 总结旧的io和nio主要有以下几点不同 io面向流，nio面向buffer io是阻塞，nio非阻塞 nio有selector，可以理解为管理多个矿场。关于selector还处于一知半解的状态，希望以后在项目中能碰到。","link":"/2018/09/14/Java-NIO/"},{"title":"Java_Serializable","text":"原因由于对象在程序结束的时候会被销毁，因此如果希望对象能够在程序不运行的时候仍然能保存信息，那么就需要用到对象的序列化操作，简单来说就是将对象转换成字节序列，等需要的时候再反序列化即可读取其中的信息。又或者在Android开发中通过intent传递对象的时候，需要将对象序列化然后才能传递。 使用方法12345678//写入文件ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(\"test.obj\"));objectOutputStream.writeObject(new Data(1));objectOutputStream.close();//读取文件ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(\"test.obj\"));Data data = (Data) objectInputStream.readObject();System.out.println(data); transient关键字如果某个类的属性不希望被序列化则可以加上transient关键字。1transient private String str; 当在反序列化读取的时候就会为null或者是类型的默认值。 序列化中的static如果在序列化之后修改了static类型的变量，那么打印出来会如何呢1234567891011121314151617181920212223242526272829class Data implements Serializable &#123; private int n; transient public static int i = 5; public Data(int n) &#123; this.n = n; &#125; @Override public String toString() &#123; return \"Data&#123;\" + \"n=\" + n + '&#125;'; &#125;&#125;public static void main(String[] args) &#123; try &#123; ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(\"test.obj\")); objectOutputStream.writeObject(new Data(1)); objectOutputStream.close(); Data.i = 10; ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(\"test.obj\")); Data data = (Data) objectInputStream.readObject(); System.out.println(data); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 结果是10，原因是static是针对类的属性，而不是针对对象的属性。因为静态变量可以直接使用，所以序列化并不保存静态变量。 ExternalizableExternalizable是一个继承Serializable的接口，并增加了两个方法1234public interface Externalizable extends Serializable &#123; void writeExternal(ObjectOutput var1) throws IOException; void readExternal(ObjectInput var1) throws IOException, ClassNotFoundException;&#125; 这两个放在分别会在write和read的时候调用，我们可以实现这个接口，如果有其他操作可以放在这两个方法中，并且他会readExternal之前调用该类的无参构造方法。123456789101112131415161718192021222324252627282930313233343536373839404142class Data implements Externalizable &#123; private int n; public Data(int n) &#123; this.n = n; &#125; public Data() &#123; System.out.println(\"no pm constructor\"); &#125; @Override public String toString() &#123; return \"Data&#123;\" + \"n=\" + n + '&#125;'; &#125; @Override public void writeExternal(ObjectOutput objectOutput) throws IOException &#123; System.out.println(\"writeExternal()\"); &#125; @Override public void readExternal(ObjectInput objectInput) throws IOException, ClassNotFoundException &#123; System.out.println(\"readExternal()\"); &#125;&#125;public static void main(String[] args) &#123; try &#123; ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(\"test.obj\")); objectOutputStream.writeObject(new Data(1)); objectOutputStream.close(); ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(\"test.obj\")); Data data = (Data) objectInputStream.readObject(); System.out.println(data); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 12345Result:writeExternal()no pm constructorreadExternal()Data&#123;n=0&#125; 奇怪的是打印出的n居然是零，但是我们写进去的是一个n=1的对象。原因是Externalizable调用了无参的构造方法重新赋值了一遍。 这也是Serializable和Externalizable最大的区别：Serializable是完全根据二级制文件来构造对象，但是Externalizable是根据构造方法和readExternal方法来构造的。 因此正确的做法需要在writeExternal和readExternal的时候写入和赋值。这样的好处是更容易控制变量的存亡。 1234567891011@Overridepublic void writeExternal(ObjectOutput objectOutput) throws IOException &#123; System.out.println(\"writeExternal()\"); objectOutput.writeInt(n);&#125;@Overridepublic void readExternal(ObjectInput objectInput) throws IOException, ClassNotFoundException &#123; System.out.println(\"readExternal()\"); n = objectInput.readInt();&#125; Externalizable的替代方法如果觉得Externalizable这样太麻烦的话，我们依然可以使用Serializable，不过需要添加两个方法。并遵循它们的特征签名1234567private void writeObject(ObjectOutputStream stream) &#123; System.out.println(Thread.currentThread().getStackTrace()[1].getMethodName());&#125;private void readObject(ObjectInputStream stream) &#123; System.out.println(Thread.currentThread().getStackTrace()[1].getMethodName());&#125; 查看下源码就知道如果我们实现了这两个方法（虽然只是添加，就当他是实现吧），那么就不会走正常的序列化流程，而转为使用我们自己实现的。1234567891011121314151617181920void invokeWriteObject(Object var1, ObjectOutputStream var2) throws IOException, UnsupportedOperationException &#123; this.requireInitialized(); if (this.writeObjectMethod != null) &#123; try &#123; this.writeObjectMethod.invoke(var1, var2); &#125; catch (InvocationTargetException var5) &#123; Throwable var4 = var5.getTargetException(); if (var4 instanceof IOException) &#123; throw (IOException)var4; &#125; throwMiscException(var4); &#125; catch (IllegalAccessException var6) &#123; throw new InternalError(var6); &#125; &#125; else &#123; throw new UnsupportedOperationException(); &#125;&#125; 如果我们自己实现的话实现方式和Externalizable一样1234567private void writeObject(ObjectOutputStream stream) throws IOException &#123; stream.writeInt(n);&#125; private void readObject(ObjectInputStream stream) throws IOException &#123; n = stream.readInt();&#125; 序列化个人认为没有特别深入的必要，只要知道使用方法即可。","link":"/2018/09/07/Java-Serializable/"},{"title":"Kotlin Constructor","text":"构造函数最近在自定义布局的时候发现kotlin的构造函数和java差的很多，因此重新学习记录下，先从简单的开始，模仿java中的写法12345class User &#123; constructor(i: Int) constructor(i: Int, j: Int) constructor(name: String, i: Int, j: Int)&#125; 123456789101112public final class User &#123; public User(int i) &#123; &#125; public User(int i, int j) &#123; &#125; public User(@NotNull String name, int i, int j) &#123; Intrinsics.checkParameterIsNotNull(name, \"name\"); super(); &#125;&#125; 可以看到这种写法和java差不多。kotlin还允许在class定义的时候直接写构造函数，这种构造函数叫主构造函数。 123class User constructor/*可省略*/(i: Int) &#123;&#125; 1234public final class User &#123; public User(int i) &#123; &#125;&#125; 像这种直接在类名旁边的叫primary constructor，而类似于java那种写法的构造函数叫Secondary Constructors。主构造函数只能有一个，次构造函数可以有多个。但是由于主构造函数不能加代码，因此kotlin提供了init关键字12345class User constructor/*可省略*/(i: Int) &#123; init &#123; println(\"primary constructor i = $i\") &#125;&#125; 123456public final class User &#123; public User(int i) &#123; String var2 = \"primary constructor i = \" + i; System.out.println(var2); &#125;&#125; 那如果想同时有主构造函数和次构造函数怎么办呢,按照官方api说的是需要或直接或间接的委托于主构造函数，一开始没看懂，后来看了转成的java源码，原来他说的委托就是在次构造函数中调用主构造函数12345678class User(name: String) &#123; init &#123; println(\"primary\") &#125; constructor() : this(String()) constructor(i: Int) : this(String()) constructor(j: Int, string: String) : this(string)&#125; 123456789101112131415161718192021public final class User &#123; public User(@NotNull String name) &#123; Intrinsics.checkParameterIsNotNull(name, \"name\"); super(); String var2 = \"primary\"; System.out.println(var2); &#125; public User() &#123; this(new String()); &#125; public User(int i) &#123; this(new String()); &#125; public User(int j, @NotNull String string) &#123; Intrinsics.checkParameterIsNotNull(string, \"string\"); this(string); &#125;&#125; 从这边可以看到init代码块中的代码是在主构造函数中的，不过由于次构造函数都会调用主构造函数，所以也无需纠结这个init代码块是否会被调用。","link":"/2018/09/06/Kotlin-Constructor/"},{"title":"Kotlin Singleton","text":"Object在\bKotlin中，\bobject是一个自带单例模式的数据类型，\b而在java中object是所有类的父类。如下是object分别在java和kotlin的代码：1234object ExampleObject &#123; fun example() &#123; &#125;&#125; 1234567891011public final class ExampleObject &#123; public static final ExampleObject INSTANCE; public final void example() &#123; &#125; static &#123; ExampleObject var0 = new ExampleObject(); INSTANCE = var0; &#125;&#125; 可以看到，kotlin中的object是对应java中的静态单例模式。因此如果想在kotlin中写出单例模式，可以直接使用object关键字即可。同时因为使用的是static实现单例模式，因此也保证了线程安全。后续会介绍更好的写法。 Java Singleton这里其实对java中使用static来实现单例模式不是很清晰，主要的问题在于为什么static修饰的对象指向的是同一个内存地址。即使我这么写12345678910public class Single &#123; public static Single single = new Single();&#125;public static void main(String[] args) &#123; Single single = Single.single; System.out.println(single); Single single1 = Single.single; System.out.println(single1);&#125; Result:12Single@2b193f2dSingle@2b193f2d 静态单例模式还有另一种方式，区别在于只有调用getInstance方法时才会去实例化\bSingle对象。12345678910public class Single &#123; private static class SingleHoleder &#123; private static Single single = new Single(); &#125; public static Single getInstance() &#123; return SingleHoleder.single; &#125;&#125; 这边static关键字能实现单例模式的主要原因在于被static修饰的变量或对象具有唯一性。那么为什么具有唯一性呢，这就得查看static的原理了。 Static关键字根据定义，被static所修饰的变量有且只有该变量的一份拷贝，并且能在类中公用。换句话说是一个全局的变量。静态变量在加载类的时候就已经\b分配好了内存，因此该变量是属于类的而不是某个new出来的对象的。在往下到jvm还未了解到,本文关于static到此结束。 更好的单例模式12345678910public class Singleton private constructor() &#123; init &#123; println(\"This ($this) is a singleton\") &#125; private object Holder &#123; val INSTANCE = Singleton() &#125; companion object &#123; val instance: Singleton by lazy &#123; Holder.INSTANCE &#125; &#125; var b:String? = null&#125; 将构造方法私有化，其他地方无法实例化该类。 使用lazy关键字延迟instance的实例化，优化性能。 使用companion关键字实现java中static的效果。 kotlin中的companion由于kotlin中object默认是单例模式，因此没有static关键字，那么如果我们想要全局变量该怎么做呢，答案就是companion。12345678910class Test private constructor() &#123; companion object &#123; val i = 1 val instance = Test() &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; println(Test.i)&#125; 1Result : 1 \b这样就实现了static的效果。再来看一下decompile后的代码12345678910111213141516171819202122232425public final class Test &#123; private static final int i = 1; @NotNull private static final Test instance = new Test(); public static final Test.Companion Companion = new Test.Companion((DefaultConstructorMarker)null); public static final class Companion &#123; public final int getI() &#123; return Test.i; &#125; @NotNull public final Test getInstance() &#123; return Test.instance; &#125; private Companion() &#123; &#125; // $FF: synthetic method public Companion(DefaultConstructorMarker $constructor_marker) &#123; this(); &#125; &#125;&#125; 可以看到变量i被static所修饰。并且companion是对所有类公开的，因此适合用来实现单例模式。 Warning:一个类中只能有一个被companion修饰的object。 参考文档： https://antonioleiva.com/objects-kotlin/ https://medium.com/@adinugroho/singleton-in-kotlin-502f80fd8a63 https://www.journaldev.com/18662/kotlin-singleton-companion-object","link":"/2018/08/09/Kotlin-Singleton/"},{"title":"Kotlin_扩展函数/属性/中缀调用","text":"Kotlin - 扩展函数扩展函数：它是一个类的成员函数，不过是定义在类的外面。比如说定义一个String的扩展函数计算该字串的最后一个字符1fun String.lastChar(): Char = this.get(this.length - 1) 当我们想调用该函数的时候1println(\"kotlin\".lastChar()) Warning: 扩展函数不能访问到私有的或者受保护的成员。 扩展函数不存在重写的情况，当一个类的成员函数和扩展函数拥有相同的签名时，成员函数会被优先使用。1234567class Button &#123; fun test() &#123; println(\"This is member fun\") &#125; &#125;val button: Button = Button() button.test() Result : This is member fun Kotlin - 扩展属性扩展属性和扩展函数类似，就像接收者的一个普通成员属性一样。Warning: 必须定义getter函数，不能初始化，因为没有地方存储初始值。12345678var StringBuilder.lastChar: Char get() = get(this.length - 1) set(value: Char) &#123; this.setCharAt(length - 1, value) &#125;val sb = StringBuilder(\"kotlin?\") sb.lastChar = '!' println(sb) Result : kotlin!具体在实战中如何使用暂时不知。不过在Collection中已经默认增加了很多扩展函数，例如last（用来获取列表中最后一个元素）或者max（获取集合中的最大值）。这些在IDE中都会在补全功能中显示出来。 Kotlin - 中缀调用中缀调用：调用函数的时候不加分隔符，直接在对象和参数之间的调用方式。1val map = mapOf(1 to \"one\", 7 to \"seven\") 等价于1val map = mapOf(1.to(\"one\"), 7.to(\"seven\")) 中缀调用可以与只有一个参数的函数一起使用，并且需要用infix修饰符来标记它。例如上述to函数的声明1public infix fun &lt;A, B&gt; A.to(that: B): Pair&lt;A, B&gt; = Pair(this, that) 个人理解增加函数调用的可读性。","link":"/2018/07/27/Kotlin-扩展函数-属性-中缀调用/"}],"tags":[],"categories":[{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Kotlin","slug":"Kotlin","link":"/categories/Kotlin/"}]}